"use strict";
import { getTools, confirm, arcade } from "./tools";
import { createAgent } from "langchain";
import {
  Command,
  MemorySaver,
  type Interrupt,
} from "@langchain/langgraph";
import chalk from "chalk";
import * as readline from "node:readline/promises";

// configure your own values to customize your agent

// The Arcade User ID identifies who is authorizing each service.
const arcadeUserID = process.env.ARCADE_USER_ID;
if (!arcadeUserID) {
  throw new Error("Missing ARCADE_USER_ID. Add it to your .env file.");
}
// This determines which MCP server is providing the tools, you can customize this to make a Slack agent, or Notion agent, etc.
// all tools from each of these MCP servers will be retrieved from arcade
const toolkits=['Hubspot'];
// This determines isolated tools that will be
const isolatedTools=[];
// This determines the maximum number of tool definitions Arcade will return
const toolLimit = 100;
// This prompt defines the behavior of the agent.
const systemPrompt = `# Introduction
Welcome to the HubSpot AI Assistant! This agent is designed to streamline your engagement processes by harnessing various tools available in the HubSpot API. Whether you need to manage deals, contacts, or communication activities, this AI agent will assist you efficiently and effectively.

# Instructions
1. **Understand the Context:** Start by identifying the specific task you want to accomplish‚Äîbe it creating, updating, or retrieving information about deals, contacts, companies, activities, or users.
2. **Use Appropriate Tools:** Select and utilize the required tools based on the context of the task.
3. **Follow the Workflows:** Adhere to the defined workflows for the best results, ensuring the correct sequence of operations.
4. **Provide Clear Input:** When prompted for specific details (like IDs, names, dates, etc.), enter clear and accurate information to facilitate smooth tool operations.
5. **Handle Outputs:** Be ready to process and respond to outputs generated by the tools, whether it‚Äôs confirming an action taken, providing data retrieved, or seeking additional information if necessary.

# Workflows

## Workflow 1: Create a New Deal
1. **Tool Used:** Hubspot_GetDealPipelines
2. **Tool Used:** Hubspot_CreateDeal

## Workflow 2: Update an Existing Deal
1. **Tool Used:** Hubspot_GetDealDataByKeywords
2. **Tool Used:** Hubspot_UpdateDeal

## Workflow 3: Create a New Contact
1. **Tool Used:** Hubspot_CreateContact

## Workflow 4: Update an Existing Contact
1. **Tool Used:** Hubspot_GetContactDataByKeywords
2. **Tool Used:** Hubspot_UpdateContact

## Workflow 5: Create a Call Activity
1. **Tool Used:** Hubspot_CreateCallActivity

## Workflow 6: Create a Meeting Activity
1. **Tool Used:** Hubspot_CreateMeetingActivity

## Workflow 7: Create an Email Activity
1. **Tool Used:** Hubspot_CreateEmailActivity

## Workflow 8: Create a Note Activity
1. **Tool Used:** Hubspot_CreateNoteActivity

## Workflow 9: Search for Communications
1. **Tool Used:** Hubspot_GetCommunicationDataByKeywords

## Workflow 10: Search for Companies
1. **Tool Used:** Hubspot_GetCompanyDataByKeywords

## Workflow 11: Search for Contacts
1. **Tool Used:** Hubspot_GetContactDataByKeywords

## Workflow 12: Search for Deals
1. **Tool Used:** Hubspot_GetDealDataByKeywords

This structure will help the agent perform tasks systematically and maximize its effectiveness in managing HubSpot engagements.`;
// This determines which LLM will be used inside the agent
const agentModel = process.env.OPENAI_MODEL;
if (!agentModel) {
  throw new Error("Missing OPENAI_MODEL. Add it to your .env file.");
}
// This allows LangChain to retain the context of the session
const threadID = "1";

const tools = await getTools({
  arcade,
  toolkits: toolkits,
  tools: isolatedTools,
  userId: arcadeUserID,
  limit: toolLimit,
});



async function handleInterrupt(
  interrupt: Interrupt,
  rl: readline.Interface
): Promise<{ authorized: boolean }> {
  const value = interrupt.value;
  const authorization_required = value.authorization_required;
  const hitl_required = value.hitl_required;
  if (authorization_required) {
    const tool_name = value.tool_name;
    const authorization_response = value.authorization_response;
    console.log("‚öôÔ∏è: Authorization required for tool call", tool_name);
    console.log(
      "‚öôÔ∏è: Please authorize in your browser",
      authorization_response.url
    );
    console.log("‚öôÔ∏è: Waiting for you to complete authorization...");
    try {
      await arcade.auth.waitForCompletion(authorization_response.id);
      console.log("‚öôÔ∏è: Authorization granted. Resuming execution...");
      return { authorized: true };
    } catch (error) {
      console.error("‚öôÔ∏è: Error waiting for authorization to complete:", error);
      return { authorized: false };
    }
  } else if (hitl_required) {
    console.log("‚öôÔ∏è: Human in the loop required for tool call", value.tool_name);
    console.log("‚öôÔ∏è: Please approve the tool call", value.input);
    const approved = await confirm("Do you approve this tool call?", rl);
    return { authorized: approved };
  }
  return { authorized: false };
}

const agent = createAgent({
  systemPrompt: systemPrompt,
  model: agentModel,
  tools: tools,
  checkpointer: new MemorySaver(),
});

async function streamAgent(
  agent: any,
  input: any,
  config: any
): Promise<Interrupt[]> {
  const stream = await agent.stream(input, {
    ...config,
    streamMode: "updates",
  });
  const interrupts: Interrupt[] = [];

  for await (const chunk of stream) {
    if (chunk.__interrupt__) {
      interrupts.push(...(chunk.__interrupt__ as Interrupt[]));
      continue;
    }
    for (const update of Object.values(chunk)) {
      for (const msg of (update as any)?.messages ?? []) {
        console.log("ü§ñ: ", msg.toFormattedString());
      }
    }
  }

  return interrupts;
}

async function main() {
  const config = { configurable: { thread_id: threadID } };
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  console.log(chalk.green("Welcome to the chatbot! Type 'exit' to quit."));
  while (true) {
    const input = await rl.question("> ");
    if (input.toLowerCase() === "exit") {
      break;
    }
    rl.pause();

    try {
      let agentInput: any = {
        messages: [{ role: "user", content: input }],
      };

      // Loop until no more interrupts
      while (true) {
        const interrupts = await streamAgent(agent, agentInput, config);

        if (interrupts.length === 0) {
          break; // No more interrupts, we're done
        }

        // Handle all interrupts
        const decisions: any[] = [];
        for (const interrupt of interrupts) {
          decisions.push(await handleInterrupt(interrupt, rl));
        }

        // Resume with decisions, then loop to check for more interrupts
        // Pass single decision directly, or array for multiple interrupts
        agentInput = new Command({ resume: decisions.length === 1 ? decisions[0] : decisions });
      }
    } catch (error) {
      console.error(error);
    }

    rl.resume();
  }
  console.log(chalk.red("üëã Bye..."));
  process.exit(0);
}

// Run the main function
main().catch((err) => console.error(err));