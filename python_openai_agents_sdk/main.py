from agents import (Agent, Runner, AgentHooks, Tool, RunContextWrapper,
                    TResponseInputItem,)
from functools import partial
from arcadepy import AsyncArcade
from agents_arcade import get_arcade_tools
from typing import Any
from human_in_the_loop import (UserDeniedToolCall,
                               confirm_tool_usage,
                               auth_tool)

import globals


class CustomAgentHooks(AgentHooks):
    def __init__(self, display_name: str):
        self.event_counter = 0
        self.display_name = display_name

    async def on_start(self,
                       context: RunContextWrapper,
                       agent: Agent) -> None:
        self.event_counter += 1
        print(f"### ({self.display_name}) {
              self.event_counter}: Agent {agent.name} started")

    async def on_end(self,
                     context: RunContextWrapper,
                     agent: Agent,
                     output: Any) -> None:
        self.event_counter += 1
        print(
            f"### ({self.display_name}) {self.event_counter}: Agent {
                # agent.name} ended with output {output}"
                agent.name} ended"
        )

    async def on_handoff(self,
                         context: RunContextWrapper,
                         agent: Agent,
                         source: Agent) -> None:
        self.event_counter += 1
        print(
            f"### ({self.display_name}) {self.event_counter}: Agent {
                source.name} handed off to {agent.name}"
        )

    async def on_tool_start(self,
                            context: RunContextWrapper,
                            agent: Agent,
                            tool: Tool) -> None:
        self.event_counter += 1
        print(
            f"### ({self.display_name}) {self.event_counter}:"
            f" Agent {agent.name} started tool {tool.name}"
            f" with context: {context.context}"
        )

    async def on_tool_end(self,
                          context: RunContextWrapper,
                          agent: Agent,
                          tool: Tool,
                          result: str) -> None:
        self.event_counter += 1
        print(
            f"### ({self.display_name}) {self.event_counter}: Agent {
                # agent.name} ended tool {tool.name} with result {result}"
                agent.name} ended tool {tool.name}"
        )


async def main():

    context = {
        "user_id": os.getenv("ARCADE_USER_ID"),
    }

    client = AsyncArcade()

    arcade_tools = await get_arcade_tools(
        client, toolkits=["Hubspot"]
    )

    for tool in arcade_tools:
        # - human in the loop
        if tool.name in ENFORCE_HUMAN_CONFIRMATION:
            tool.on_invoke_tool = partial(
                confirm_tool_usage,
                tool_name=tool.name,
                callback=tool.on_invoke_tool,
            )
        # - auth
        await auth_tool(client, tool.name, user_id=context["user_id"])

    agent = Agent(
        name="",
        instructions="# Introduction
Welcome to the HubSpot AI Assistant! This agent is designed to streamline your engagement processes by harnessing various tools available in the HubSpot API. Whether you need to manage deals, contacts, or communication activities, this AI agent will assist you efficiently and effectively.

# Instructions
1. **Understand the Context:** Start by identifying the specific task you want to accomplish—be it creating, updating, or retrieving information about deals, contacts, companies, activities, or users.
2. **Use Appropriate Tools:** Select and utilize the required tools based on the context of the task.
3. **Follow the Workflows:** Adhere to the defined workflows for the best results, ensuring the correct sequence of operations.
4. **Provide Clear Input:** When prompted for specific details (like IDs, names, dates, etc.), enter clear and accurate information to facilitate smooth tool operations.
5. **Handle Outputs:** Be ready to process and respond to outputs generated by the tools, whether it’s confirming an action taken, providing data retrieved, or seeking additional information if necessary.

# Workflows

## Workflow 1: Create a New Deal
1. **Tool Used:** Hubspot_GetDealPipelines
2. **Tool Used:** Hubspot_CreateDeal

## Workflow 2: Update an Existing Deal
1. **Tool Used:** Hubspot_GetDealDataByKeywords
2. **Tool Used:** Hubspot_UpdateDeal

## Workflow 3: Create a New Contact
1. **Tool Used:** Hubspot_CreateContact

## Workflow 4: Update an Existing Contact
1. **Tool Used:** Hubspot_GetContactDataByKeywords
2. **Tool Used:** Hubspot_UpdateContact

## Workflow 5: Create a Call Activity
1. **Tool Used:** Hubspot_CreateCallActivity

## Workflow 6: Create a Meeting Activity
1. **Tool Used:** Hubspot_CreateMeetingActivity

## Workflow 7: Create an Email Activity
1. **Tool Used:** Hubspot_CreateEmailActivity

## Workflow 8: Create a Note Activity
1. **Tool Used:** Hubspot_CreateNoteActivity

## Workflow 9: Search for Communications
1. **Tool Used:** Hubspot_GetCommunicationDataByKeywords

## Workflow 10: Search for Companies
1. **Tool Used:** Hubspot_GetCompanyDataByKeywords

## Workflow 11: Search for Contacts
1. **Tool Used:** Hubspot_GetContactDataByKeywords

## Workflow 12: Search for Deals
1. **Tool Used:** Hubspot_GetDealDataByKeywords

This structure will help the agent perform tasks systematically and maximize its effectiveness in managing HubSpot engagements.",
        model=os.environ["OPENAI_MODEL"],
        tools=arcade_tools,
        hooks=CustomAgentHooks(display_name="")
    )

    # initialize the conversation
    history: list[TResponseInputItem] = []
    # run the loop!
    while True:
        prompt = input("You: ")
        if prompt.lower() == "exit":
            break
        history.append({"role": "user", "content": prompt})
        try:
            result = await Runner.run(
                starting_agent=agent,
                input=history,
                context=context
            )
            history = result.to_input_list()
            print(result.final_output)
        except UserDeniedToolCall as e:
            history.extend([
                {"role": "assistant",
                 "content": f"Please confirm the call to {e.tool_name}"},
                {"role": "user",
                 "content": "I changed my mind, please don't do it!"},
                {"role": "assistant",
                 "content": f"Sure, I cancelled the call to {e.tool_name}."
                 " What else can I do for you today?"
                 },
            ])
            print(history[-1]["content"])

if __name__ == "__main__":
    import asyncio

    asyncio.run(main())